# Epic 1 Retrospective — Project Foundation & Core Infrastructure

Date: 2026-02-27
Scope: Stories 1.1 → 1.7

## Context

Epic 1 established the technical foundation for Spetaka: Flutter project scaffolding, core architecture boundaries, persistence (Drift), navigation + design system, core utilities (lifecycle/actions), encryption primitives, repository-layer field encryption (NFR6), and CI/CD.

The success criterion for this epic is not end-user features, but a stable, testable, privacy-aligned platform that unblocks every subsequent epic.

## What Shipped (Outcomes)

- Flutter project scaffold with feature-first structure (`core/`, `features/`, `shared/`) and consistent linting/codegen conventions.
- Drift database foundation with migration strategy, DAO structure, and in-memory test fixtures.
- AES-256-GCM `EncryptionService` with PBKDF2-derived key, persisted salt (only), typed error surfaces, and provider integration.
- App shell foundation: GoRouter route tree, Material 3 theming (light + warm dark mode), centralized tokens, and reusable loading/error states.
- Core utilities:
  - `AppLifecycleService` as the single lifecycle observer
  - `PhoneNormalizer` as the single normalization source of truth
  - `ContactActionService` as the single `url_launcher` gateway
- GitHub Actions workflow enforcing analyze → test → release build, caching, deterministic toolchain pinning, and codegen drift detection.
- Repository-layer encryption boundary (encrypt on write / decrypt on read) with “ciphertext at rest” tests and typed failure behavior.

## What Went Well

- **Architecture guardrails held under iteration.** The repository boundary for business logic (including encryption) remained enforceable and testable, which should reduce feature-epic coupling.
- **Typed errors + central messaging paid off early.** Converting crypto, normalization, and launch failures into domain errors prevented “raw exception leakage” and set up a consistent UX path for later epics.
- **Test-first infrastructure was used as a design tool.** In-memory DB fixtures, provider integration tests, and “ciphertext at rest” assertions caught layering mistakes quickly.
- **CI became a real safety net.** The pipeline’s determinism, caching discipline, and codegen-diff check reduced the risk of “works locally” drift.

## What Was Challenging

- **Cross-cutting concerns surfaced spec/implementation drift.** Examples included naming mismatches (spec vs file names), story task checklists diverging from actual repo state, and “foundation” stories that needed follow-up review passes to align docs and code.
- **Lifecycle behavior is easy to scatter.** Encryption key clearing initially lived with the service and later had to be centralized to preserve the “single observer” rule.
- **Security-by-default required extra hardening.** Salt corruption, initialization failures, and avoidance of PII in error reasons needed explicit handling rather than relying on defaults.
- **Schema bootstrapping vs future epics.** Introducing minimal tables/migrations early (to test encryption at rest) creates coordination needs with later domain stories.

## Key Decisions (Worth Repeating)

- **No SQLCipher for v1**: rely on field-level encryption at repository boundaries to satisfy at-rest encryption requirements while keeping Drift usage straightforward.
- **One lifecycle observer**: `WidgetsBindingObserver` usage is isolated in `AppLifecycleService` to reduce global side effects.
- **One gateway per cross-cutting concern**:
  - Phone normalization is centralized.
  - External communication intents are centralized.
  - Encryption primitives are centralized.
- **Code generation is a contract**: CI validates generated output matches what is committed.

## Learnings

- The “foundation” epic benefits from an explicit review step even when tests are green, because many issues are *semantic* (layering, naming, UX surface contracts) rather than purely functional.
- Error design is part of architecture: preventing PII leakage and avoiding raw exception propagation are easier to do early than retrofit later.
- Encryption is never “just crypto”: lifecycle, storage boundaries, and failure modes are equally important.

## Action Items (Next Improvements)

- Standardize story artifact conventions so AC wording, filenames, and file lists stay aligned with repo reality.
- Decide how to handle schema coordination between “infrastructure-first tables” and upcoming feature stories (avoid duplicated migrations or table redefinitions).
- Consider a versioned ciphertext prefix strategy for future-proofing encryption format evolution (without changing current format in-place).
- When schema stabilizes, consider adding relational constraints where appropriate (migrations required).

## Epic 2 Preview (Readiness)

Epic 2 (Friend Cards & Circle Management) is unblocked by this foundation:

- Persistence layer and migrations are in place.
- Navigation scaffold and theming/tokens exist for consistent screens.
- Contact import and action utilities have a single, testable interface.
- Sensitive narrative fields already have an encryption boundary pattern (repository-level), which should reduce risk when adding notes and concern flags.

Primary attention areas for Epic 2 execution:

- Keep the repository boundary clean as friend creation/edit flows evolve.
- Ensure contact permission and normalization behavior remains deterministic and non-leaky.
- Keep UI placeholders and route contracts stable so downstream screens don’t churn imports.
